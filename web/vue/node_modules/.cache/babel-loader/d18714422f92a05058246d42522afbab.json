{"remainingRequest":"/Users/adr/Library/Mobile Documents/com~apple~CloudDocs/gekko/web/vue/node_modules/thread-loader/dist/cjs.js!/Users/adr/Library/Mobile Documents/com~apple~CloudDocs/gekko/web/vue/node_modules/babel-loader/lib/index.js!/Users/adr/Library/Mobile Documents/com~apple~CloudDocs/gekko/web/vue/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/adr/Library/Mobile Documents/com~apple~CloudDocs/gekko/web/vue/src/components/gekko/new.vue?vue&type=script&lang=js","dependencies":[{"path":"/Users/adr/Library/Mobile Documents/com~apple~CloudDocs/gekko/web/vue/src/components/gekko/new.vue","mtime":1569604667000},{"path":"/Users/adr/Library/Mobile Documents/com~apple~CloudDocs/gekko/web/vue/node_modules/cache-loader/dist/cjs.js","mtime":1569708698000},{"path":"/Users/adr/Library/Mobile Documents/com~apple~CloudDocs/gekko/web/vue/node_modules/thread-loader/dist/cjs.js","mtime":1569708698000},{"path":"/Users/adr/Library/Mobile Documents/com~apple~CloudDocs/gekko/web/vue/node_modules/babel-loader/lib/index.js","mtime":1529635966000},{"path":"/Users/adr/Library/Mobile Documents/com~apple~CloudDocs/gekko/web/vue/node_modules/vue-loader/lib/index.js","mtime":1527860006000}],"contextDependencies":[],"result":["import \"core-js/modules/es7.array.includes\";\nimport \"core-js/modules/es6.string.includes\";\nimport \"core-js/modules/es6.array.find\";\nimport \"core-js/modules/es6.promise\";\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\nimport _ from 'lodash';\nimport Vue from 'vue';\nimport { post } from '../../tools/ajax';\nimport gekkoConfigBuilder from './gekkoConfigBuilder.vue';\nimport spinner from '../global/blockSpinner.vue';\nexport default {\n  components: {\n    gekkoConfigBuilder: gekkoConfigBuilder,\n    spinner: spinner\n  },\n  data: function data() {\n    return {\n      pendingStratrunner: false,\n      config: {}\n    };\n  },\n  computed: {\n    gekkos: function gekkos() {\n      return this.$store.state.gekkos;\n    },\n    watchConfig: function watchConfig() {\n      var raw = _.pick(this.config, 'watch', 'candleWriter');\n\n      var watchConfig = Vue.util.extend({}, raw);\n      watchConfig.type = 'market watcher';\n      watchConfig.mode = 'realtime';\n      return watchConfig;\n    },\n    requiredHistoricalData: function requiredHistoricalData() {\n      if (!this.config.tradingAdvisor || !this.config.valid) return;\n      var stratSettings = this.config.tradingAdvisor;\n      return stratSettings.candleSize * stratSettings.historySize;\n    },\n    gekkoConfig: function gekkoConfig() {\n      var startAt;\n      if (!this.existingMarketWatcher) return;\n      if (!this.requiredHistoricalData) startAt = moment().utc().startOf('minute').format();else {\n        // TODO: figure out whether we can stitch data\n        // without looking at the existing watcher\n        var optimal = moment().utc().startOf('minute').subtract(this.requiredHistoricalData, 'minutes').unix();\n        var available = moment.utc(this.existingMarketWatcher.events.initial.candle.start).unix();\n        startAt = moment.unix(Math.max(optimal, available)).utc().format();\n      }\n      var gekkoConfig = Vue.util.extend({\n        market: {\n          type: 'leech',\n          from: startAt\n        },\n        mode: 'realtime'\n      }, this.config);\n      return gekkoConfig;\n    },\n    existingMarketWatcher: function existingMarketWatcher() {\n      var market = Vue.util.extend({}, this.watchConfig.watch);\n      return _.find(this.gekkos, {\n        config: {\n          watch: market\n        }\n      });\n    },\n    exchange: function exchange() {\n      return this.watchConfig.watch.exchange;\n    },\n    existingTradebot: function existingTradebot() {\n      var _this = this;\n\n      return _.find(this.gekkos, function (g) {\n        if (g.logType === 'tradebot' && g.config.watch.exchange === _this.exchange) {\n          return true;\n        }\n\n        return false;\n      });\n    },\n    availableApiKeys: function availableApiKeys() {\n      return this.$store.state.apiKeys;\n    }\n  },\n  watch: {\n    // start the stratrunner\n    existingMarketWatcher: function existingMarketWatcher(val, prev) {\n      var _this2 = this;\n\n      if (!this.pendingStratrunner) return;\n      var gekko = this.existingMarketWatcher;\n\n      if (gekko.events.latest.candle) {\n        this.pendingStratrunner = false;\n        this.startGekko(function (err, resp) {\n          _this2.$router.push({\n            path: \"/live-gekkos/\".concat(resp.id)\n          });\n        });\n      }\n    }\n  },\n  methods: {\n    updateConfig: function updateConfig(config) {\n      this.config = config;\n    },\n    start: function start() {\n      var _this3 = this;\n\n      // if the user starts a tradebot we do some\n      // checks first.\n      if (this.config.type === 'tradebot') {\n        if (this.existingTradebot) {\n          var str = 'You already have a tradebot running on this exchange';\n          str += ', you can only run one tradebot per exchange.';\n          return alert(str);\n        }\n\n        if (!this.availableApiKeys.includes(this.exchange)) return alert('Please first configure API keys for this exchange in the config page.');\n      } // internally a live gekko consists of two parts:\n      //\n      // - a market watcher\n      // - a live gekko (strat runner + (paper) trader)\n      //\n      // however if the user selected type \"market watcher\"\n      // the second part won't be created\n\n\n      if (this.config.type === 'market watcher') {\n        // check if the specified market is already being watched\n        if (this.existingMarketWatcher) {\n          alert('This market is already being watched, redirecting you now...');\n          this.$router.push({\n            path: \"/live-gekkos/\".concat(this.existingMarketWatcher.id)\n          });\n        } else {\n          this.startWatcher(function (error, resp) {\n            _this3.$router.push({\n              path: \"/live-gekkos/\".concat(resp.id)\n            });\n          });\n        }\n      } else {\n        if (this.existingMarketWatcher) {\n          // the specified market is already being watched,\n          // just start a gekko!\n          this.startGekko(this.routeToGekko);\n        } else {\n          // the specified market is not yet being watched,\n          // we need to create a watcher\n          this.startWatcher(function (err, resp) {\n            _this3.pendingStratrunner = resp.id; // now we just wait for the watcher to be properly initialized\n            // (see the `watch.existingMarketWatcher` method)\n          });\n        }\n      }\n    },\n    routeToGekko: function routeToGekko(err, resp) {\n      if (err || resp.error) return console.error(err, resp.error);\n      this.$router.push({\n        path: \"/live-gekkos/\".concat(resp.id)\n      });\n    },\n    startWatcher: function startWatcher(next) {\n      post('startGekko', this.watchConfig, next);\n    },\n    startGekko: function startGekko(next) {\n      post('startGekko', this.gekkoConfig, next);\n    }\n  }\n};",{"version":3,"sources":["new.vue"],"names":[],"mappings":"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","sourcesContent":["<template lang='pug'>\n  div.contain.my2\n    h3 Start a new gekko\n    gekko-config-builder(v-on:config='updateConfig')\n    .hr\n    .txt--center(v-if='config.valid')\n      a.w100--s.my1.btn--primary(href='#', v-on:click.prevent='start', v-if=\"!pendingStratrunner\") Start\n      spinner(v-if='pendingStratrunner')\n</template>\n\n<script>\n\nimport _ from 'lodash'\nimport Vue from 'vue'\nimport { post } from '../../tools/ajax'\nimport gekkoConfigBuilder from './gekkoConfigBuilder.vue'\nimport spinner from '../global/blockSpinner.vue'\n\nexport default {\n  components: {\n    gekkoConfigBuilder,\n    spinner\n  },\n  data: () => {\n    return {\n      pendingStratrunner: false,\n      config: {}\n    }\n  },\n  computed: {\n    gekkos: function() {\n      return this.$store.state.gekkos;\n    },\n    watchConfig: function() {\n      let raw = _.pick(this.config, 'watch', 'candleWriter');\n      let watchConfig = Vue.util.extend({}, raw);\n      watchConfig.type = 'market watcher';\n      watchConfig.mode = 'realtime';\n      return watchConfig;\n    },\n    requiredHistoricalData: function() {\n      if(!this.config.tradingAdvisor || !this.config.valid)\n        return;\n\n      let stratSettings = this.config.tradingAdvisor;\n      return stratSettings.candleSize * stratSettings.historySize;\n    },\n    gekkoConfig: function() {\n      var startAt;\n\n      if(!this.existingMarketWatcher)\n        return;\n\n      if(!this.requiredHistoricalData)\n        startAt = moment().utc().startOf('minute').format();\n      else {\n        // TODO: figure out whether we can stitch data\n        // without looking at the existing watcher\n        const optimal = moment().utc().startOf('minute')\n          .subtract(this.requiredHistoricalData, 'minutes')\n          .unix();\n\n        const available = moment\n          .utc(this.existingMarketWatcher.events.initial.candle.start)\n          .unix();\n\n        startAt = moment.unix(Math.max(optimal, available)).utc().format();\n      }\n\n      const gekkoConfig = Vue.util.extend({\n        market: {\n          type: 'leech',\n          from: startAt\n        },\n        mode: 'realtime'\n      }, this.config);\n      return gekkoConfig;\n    },\n    existingMarketWatcher: function() {\n      const market = Vue.util.extend({}, this.watchConfig.watch);\n      return _.find(this.gekkos, {config: {watch: market}});\n    },\n    exchange: function() {\n      return this.watchConfig.watch.exchange;\n    },\n    existingTradebot: function() {\n      return _.find(\n        this.gekkos,\n        g => {\n          if(g.logType === 'tradebot' && g.config.watch.exchange === this.exchange) {\n            return true;\n          }\n\n          return false;\n        }\n      );\n    },\n    availableApiKeys: function() {\n      return this.$store.state.apiKeys;\n    }\n  },\n  watch: {\n    // start the stratrunner\n    existingMarketWatcher: function(val, prev) {\n      if(!this.pendingStratrunner)\n        return;\n\n      const gekko = this.existingMarketWatcher;\n\n      if(gekko.events.latest.candle) {\n        this.pendingStratrunner = false;\n\n        this.startGekko((err, resp) => {\n          this.$router.push({\n            path: `/live-gekkos/${resp.id}`\n          });\n        });\n      }\n    }\n  },\n  methods: {\n    updateConfig: function(config) {\n      this.config = config;\n    },\n    start: function() {\n\n      // if the user starts a tradebot we do some\n      // checks first.\n      if(this.config.type === 'tradebot') {\n        if(this.existingTradebot) {\n          let str = 'You already have a tradebot running on this exchange';\n          str += ', you can only run one tradebot per exchange.';\n          return alert(str);\n        }\n\n        if(!this.availableApiKeys.includes(this.exchange))\n          return alert('Please first configure API keys for this exchange in the config page.')\n      }\n\n      // internally a live gekko consists of two parts:\n      //\n      // - a market watcher\n      // - a live gekko (strat runner + (paper) trader)\n      //\n      // however if the user selected type \"market watcher\"\n      // the second part won't be created\n      if(this.config.type === 'market watcher') {\n\n        // check if the specified market is already being watched\n        if(this.existingMarketWatcher) {\n          alert('This market is already being watched, redirecting you now...');\n          this.$router.push({\n            path: `/live-gekkos/${this.existingMarketWatcher.id}`\n          });\n        } else {\n          this.startWatcher((error, resp) => {\n            this.$router.push({\n              path: `/live-gekkos/${resp.id}`\n            });\n          });\n        }\n\n      } else {\n\n        if(this.existingMarketWatcher) {\n          // the specified market is already being watched,\n          // just start a gekko!\n          this.startGekko(this.routeToGekko);\n          \n        } else {\n          // the specified market is not yet being watched,\n          // we need to create a watcher\n          this.startWatcher((err, resp) => {\n            this.pendingStratrunner = resp.id;\n            // now we just wait for the watcher to be properly initialized\n            // (see the `watch.existingMarketWatcher` method)\n          });\n        }\n      }\n    },\n    routeToGekko: function(err, resp) {\n      if(err || resp.error)\n        return console.error(err, resp.error);\n\n      this.$router.push({\n        path: `/live-gekkos/${resp.id}`\n      });\n    },\n    startWatcher: function(next) {\n      post('startGekko', this.watchConfig, next);\n    },\n    startGekko: function(next) {\n      post('startGekko', this.gekkoConfig, next);\n    }\n  }\n}\n</script>\n\n<style>\n</style>\n"],"sourceRoot":"src/components/gekko"}]}